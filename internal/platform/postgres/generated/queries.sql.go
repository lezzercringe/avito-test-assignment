// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllReviewersForPRs = `-- name: DeleteAllReviewersForPRs :exec
DELETE FROM reviewers WHERE pull_request_id = ANY($1::varchar[])
`

func (q *Queries) DeleteAllReviewersForPRs(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, deleteAllReviewersForPRs, dollar_1)
	return err
}

const deleteReviewers = `-- name: DeleteReviewers :exec
DELETE FROM reviewers WHERE pull_request_id = $1 AND user_id = ANY($2::varchar[])
`

type DeleteReviewersParams struct {
	PullRequestID string
	Column2       []string
}

func (q *Queries) DeleteReviewers(ctx context.Context, arg DeleteReviewersParams) error {
	_, err := q.db.Exec(ctx, deleteReviewers, arg.PullRequestID, arg.Column2)
	return err
}

const getManyPullRequestsByReviewerID = `-- name: GetManyPullRequestsByReviewerID :many
SELECT id, name, original_team_name, author_id, status, merged_at FROM pull_requests pr
JOIN reviewers r ON pr.id = r.pull_request_id
WHERE r.user_id = $1
`

func (q *Queries) GetManyPullRequestsByReviewerID(ctx context.Context, userID string) ([]PullRequest, error) {
	rows, err := q.db.Query(ctx, getManyPullRequestsByReviewerID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PullRequest
	for rows.Next() {
		var i PullRequest
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalTeamName,
			&i.AuthorID,
			&i.Status,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyTeamsByNames = `-- name: GetManyTeamsByNames :many
SELECT name FROM teams
WHERE name = ANY($1::varchar[])
`

func (q *Queries) GetManyTeamsByNames(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getManyTeamsByNames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManyUsersByIDs = `-- name: GetManyUsersByIDs :many
SELECT id, name, active FROM users
WHERE id = ANY($1::varchar[])
`

func (q *Queries) GetManyUsersByIDs(ctx context.Context, dollar_1 []string) ([]User, error) {
	rows, err := q.db.Query(ctx, getManyUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name, &i.Active); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRReviewers = `-- name: GetPRReviewers :many
SELECT user_id FROM reviewers WHERE pull_request_id = $1
`

func (q *Queries) GetPRReviewers(ctx context.Context, pullRequestID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getPRReviewers, pullRequestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPRsWithAnyReviewers = `-- name: GetPRsWithAnyReviewers :many
SELECT
    pr.id,
    pr.name,
    pr.original_team_name,
    pr.author_id,
    pr.status,
    pr.merged_at,
    ARRAY_AGG(r.user_id)::varchar[] AS matched_reviewer_ids
FROM pull_requests pr
JOIN reviewers r
  ON pr.id = r.pull_request_id
WHERE r.user_id = ANY($1::varchar[])
  -- AND pr.status = "OPEN"
GROUP BY pr.id, pr.name, pr.original_team_name, pr.author_id, pr.status, pr.merged_at
ORDER BY pr.id
`

type GetPRsWithAnyReviewersRow struct {
	ID                 string
	Name               string
	OriginalTeamName   string
	AuthorID           string
	Status             string
	MergedAt           pgtype.Timestamptz
	MatchedReviewerIds []string
}

func (q *Queries) GetPRsWithAnyReviewers(ctx context.Context, dollar_1 []string) ([]GetPRsWithAnyReviewersRow, error) {
	rows, err := q.db.Query(ctx, getPRsWithAnyReviewers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPRsWithAnyReviewersRow
	for rows.Next() {
		var i GetPRsWithAnyReviewersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OriginalTeamName,
			&i.AuthorID,
			&i.Status,
			&i.MergedAt,
			&i.MatchedReviewerIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPullRequestByID = `-- name: GetPullRequestByID :one

SELECT id, name, original_team_name, author_id, status, merged_at FROM pull_requests
WHERE id = $1
`

// PRs
func (q *Queries) GetPullRequestByID(ctx context.Context, id string) (PullRequest, error) {
	row := q.db.QueryRow(ctx, getPullRequestByID, id)
	var i PullRequest
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginalTeamName,
		&i.AuthorID,
		&i.Status,
		&i.MergedAt,
	)
	return i, err
}

const getTeamByMemberID = `-- name: GetTeamByMemberID :one
SELECT name FROM teams t
JOIN memberships m ON m.team_name = t.name 
WHERE m.user_id = $1
`

func (q *Queries) GetTeamByMemberID(ctx context.Context, userID string) (string, error) {
	row := q.db.QueryRow(ctx, getTeamByMemberID, userID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getTeamByName = `-- name: GetTeamByName :one

SELECT name FROM teams
WHERE name = $1
`

// TEAMS
func (q *Queries) GetTeamByName(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRow(ctx, getTeamByName, name)
	err := row.Scan(&name)
	return name, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT user_id FROM memberships WHERE team_name = $1
`

func (q *Queries) GetTeamMembers(ctx context.Context, teamName string) ([]string, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, teamName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, name, active FROM users
WHERE id = $1
`

// USERS
func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(&i.ID, &i.Name, &i.Active)
	return i, err
}

const saveManyPullRequests = `-- name: SaveManyPullRequests :exec
INSERT INTO pull_requests(id, name, original_team_name, author_id, status, merged_at)
SELECT UNNEST($1::varchar[]), UNNEST($2::varchar[]), UNNEST($3::varchar[]), UNNEST($4::varchar[]), UNNEST($5::varchar[]), UNNEST($6::timestamptz[])
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    original_team_name = EXCLUDED.original_team_name,
    author_id = EXCLUDED.author_id,
    status = EXCLUDED.status,
    merged_at = EXCLUDED.merged_at
`

type SaveManyPullRequestsParams struct {
	Column1 []string
	Column2 []string
	Column3 []string
	Column4 []string
	Column5 []string
	Column6 []time.Time
}

func (q *Queries) SaveManyPullRequests(ctx context.Context, arg SaveManyPullRequestsParams) error {
	_, err := q.db.Exec(ctx, saveManyPullRequests,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	return err
}

const saveManyReviewers = `-- name: SaveManyReviewers :exec
INSERT INTO reviewers (pull_request_id, user_id)
SELECT UNNEST($1::varchar[]), UNNEST($2::varchar[])
ON CONFLICT (user_id, pull_request_id) DO NOTHING
`

type SaveManyReviewersParams struct {
	Column1 []string
	Column2 []string
}

func (q *Queries) SaveManyReviewers(ctx context.Context, arg SaveManyReviewersParams) error {
	_, err := q.db.Exec(ctx, saveManyReviewers, arg.Column1, arg.Column2)
	return err
}

const saveManyUsers = `-- name: SaveManyUsers :exec
INSERT INTO users (id, name, active)
SELECT UNNEST($1::varchar[]), UNNEST($2::varchar[]), UNNEST($3::boolean[])
ON CONFLICT (id)
DO UPDATE SET
    name = EXCLUDED.name,
    active = EXCLUDED.active
`

type SaveManyUsersParams struct {
	Column1 []string
	Column2 []string
	Column3 []bool
}

func (q *Queries) SaveManyUsers(ctx context.Context, arg SaveManyUsersParams) error {
	_, err := q.db.Exec(ctx, saveManyUsers, arg.Column1, arg.Column2, arg.Column3)
	return err
}

const saveMembership = `-- name: SaveMembership :exec
INSERT INTO memberships (team_name, user_id) VALUES ($1, $2)
`

type SaveMembershipParams struct {
	TeamName string
	UserID   string
}

func (q *Queries) SaveMembership(ctx context.Context, arg SaveMembershipParams) error {
	_, err := q.db.Exec(ctx, saveMembership, arg.TeamName, arg.UserID)
	return err
}

const savePullRequest = `-- name: SavePullRequest :exec
INSERT INTO pull_requests(id, name, original_team_name, author_id, status, merged_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    original_team_name = EXCLUDED.original_team_name,
    author_id = EXCLUDED.author_id,
    status = EXCLUDED.status,
    merged_at = EXCLUDED.merged_at
`

type SavePullRequestParams struct {
	ID               string
	Name             string
	OriginalTeamName string
	AuthorID         string
	Status           string
	MergedAt         pgtype.Timestamptz
}

func (q *Queries) SavePullRequest(ctx context.Context, arg SavePullRequestParams) error {
	_, err := q.db.Exec(ctx, savePullRequest,
		arg.ID,
		arg.Name,
		arg.OriginalTeamName,
		arg.AuthorID,
		arg.Status,
		arg.MergedAt,
	)
	return err
}

const saveReviewers = `-- name: SaveReviewers :exec
INSERT INTO reviewers (pull_request_id, user_id) 
SELECT $1, UNNEST($2::varchar[])
ON CONFLICT (user_id, pull_request_id) DO NOTHING
`

type SaveReviewersParams struct {
	PullRequestID string
	Column2       []string
}

func (q *Queries) SaveReviewers(ctx context.Context, arg SaveReviewersParams) error {
	_, err := q.db.Exec(ctx, saveReviewers, arg.PullRequestID, arg.Column2)
	return err
}

const saveTeam = `-- name: SaveTeam :exec
INSERT INTO teams (name) VALUES ($1)
ON CONFLICT (name)
DO UPDATE SET name = EXCLUDED.name
`

func (q *Queries) SaveTeam(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, saveTeam, name)
	return err
}

const saveUser = `-- name: SaveUser :exec
INSERT INTO users (id, name, active) VALUES ($1, $2, $3)
ON CONFLICT (id) 
DO UPDATE SET name = excluded.name, active = excluded.active
`

type SaveUserParams struct {
	ID     string
	Name   string
	Active bool
}

func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) error {
	_, err := q.db.Exec(ctx, saveUser, arg.ID, arg.Name, arg.Active)
	return err
}
